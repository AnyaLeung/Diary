# 哪些问题是动态规划可以解决的，递推、贪心和动态规划的关系

怎么鉴定dp可解的一类问题需要从计算机是怎么工作的说起</br>
计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态</br>

当你企图使用计算机解决一个问题时，其实就是在思考</br>

* 如何将这个问题表达成状态（用哪些变量存储哪些数据）
* 如何在状态中转移（怎样根据一些变量计算出另一些变量）</br>

所以空间复杂度就是为了支持你的计算所**必需存储的状态最多有多少**</br>
所谓时间复杂度就是**从初始状态到达最终状态中间需要多少步**

举个🌰：</br>
	比如说计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。</br>
所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；</br>
每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</br>
上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫**递推**。</br>

走了n步可能处于的位置称为一个**状态**，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。</br>
所谓**阶段**是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。</br>

再举一个🌰：</br>
从棋盘的左上角到达右下角最短需要几步。</br>
Brute force：计算出所有阶段的所有状态进行比较。</br></br>
另一种方法：并不真的计算所有的状态。更好的方法，就是确保每一步走的都是最远的。</br>
换成一句熟悉话叫做: **下一步最优是从当前最优得到的**。只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫**贪心**。计算的方法是递推。</br>
在贪心可以解决的问题中，一个阶段的最优可以由前一个阶段的最优得到。</br></br>

如果一个阶段的最优无法用前一个阶段的最优得到呢？</br>
比如计算从迷宫起点到迷宫终点的最短路线</br>
因为要求最短，所以必须知道之前走过的所有位置。这时需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态。</br>
这个时候的时间复杂度是指数的。而之前的路线会影响到下一步的选择的情况，叫做**后效性**。</br>

而有一类问题，看似需要之前所有的状态，其实不用。比如说最长上升子序列问题。</br>
用搜索的话，就需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。</br>
但是我们忽然发现，每当决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了，也就是说和之前迷宫问题的本质不同，不需要记录所有的状态，时间复杂度自然也不是指数了。
但是我们还是需要这个序列的长度的，所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程

![](http://ournohp4z.bkt.clouddn.com/dp.png)

所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的。

* 每个阶段只有一个状态 -> 递推；
* 每个阶段的最优状态都是由上一个阶段的最优状态得到的 -> 贪心

* 每个阶段的最优状态是由之前所有阶段的状态的组合得到的 -> 搜索

* 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的 -> 动态规划</br>
